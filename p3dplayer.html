<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>P3D Player -(+_+)-</title>
		<style>
			body {
				margin: 0;
				overflow: hidden;
				background: #fff;
				font-family: monospace;
				color: #fff;
			}
			.app {
				background: #000;
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			a {
				color: #fff;
				cursor: pointer;
				text-decoration: underline;
			}
			.fghf {
				position: absolute;
				top: 10px;
				left: 10px;
			}
			#sasw {
				position: absolute;
				top: 10px;
				right: 10px;
				float: right;
				display: inline-block;
			}
			#sasw > select {
				position: absolute;
				font: inherit;
				opacity: 0;
				cursor: pointer;
				top: 0px;
				left: 0px;
				width: 100%;
				height: 100%;
			}
		</style>
	</head>
	<body id="drop_zone">
		<div class="app">
			<div id="pinkswf"></div>
			<a id="sasw">Sample p3d<select id="ecdx">
					<option value="" style="display: none;"></option>
					<option value="803ee0eed5ed3c505d4d8283199e6f5b.wav">Doctor Whooves VS Angel Bunny</option>
					<option value="b75bb577002b23e3443d8d916f116acb.wav">bandicam 2024-09-26 22-00-40-413 (1)</option>
					<option value="0e70751667ec5a096b1e5d0f5fc5b5e7.wav">[MLP] Angel Bunny Gets Hurt (Season 7, Episode 5)</option>
					<option value="884895aedf5829ba0a3860fd7ff7aa9d.wav">...</option>
					<option value="1c5f3533eec3d04dbe9cfd43a9a34f49.wav">Game Over Screens Nes - Part 1</option>
					<option value="747224cbb72ca914254d021eb9c7d1f3.wav">Block 13 S01E01 (English Subs)</option>
					<option value="4362a6df8dca661850dc7f8acdc83bed.wav">MLP Comic Dub_ ‘Angel Bunny Receives His Recompense’ (comedy)</option>
					<option value="18fb1da01d9c6a31071c5d5d66fe7e52.wav">Derpys Apology</option>
					<option value="6cad10b3523b57ed190ed8cf669fcf3d.wav">Twidash Pony Girl Extended</option>
					<option value="d7a1882ed945b331dd77521679b75fdd.wav">Derp She Is_v720P.mp4</option>
					<option value="2194c1ae0fe881101efacadf875fa09f.wav">Game Over Screens Nes - Part 2</option>
					<option value="3393394f2ad7fd992ccce662bc0fe458.wav">Derpys Christmas_v720P</option>
					<option value="9a8a4f7318052760d35c7af91a57a86c.wav">Rainbow Dash Is Excited</option>
					<option value="e2e3a2bb49de25236d122a7d12d91359.wav">Your Joke is So Funny</option>
					<option value="e4abb725c1bfced1bb5c93baf6a30217.wav">Space Reverse  Channel Trailer</option>
					<option value="236f6bb9454cdee213b3de2971cbc64f.wav">DinkySharkFighter32 new camera</option>
					<option value="8a9050b7ab42282db08db94a49b21c9a.wav">Neverending Orbit  Islands In Space</option>
					<option value="7d20e35b58ffc0470dca7c63a05ee2d7.wav">vroom vroom</option>
					<option value="09dccf8de3d9cef3d124e06f04e01a44.wav">Bunny Party Original MLP Animation</option>
					<option value="e7daae91cf6c13253744f29f9f3adc2e.wav">Derp She Is Derpy  Doctor</option>
					<option value="1cc2b0f58375e6c2a967326de4127d8d.wav">Derpy  Nyan Nyan Dance</option>
					<option value="258aadcf7af17b82795d999b55acaaa3.wav">[Love Live Waffles] Monster Walk</option>
					<option value="571446e98ee3cf529ee947a59a1c3e4c.wav">BONG REVILLA BUDOTS COMMERCIAL</option>
				</select>
			</a>
			<div class="fghf">
				<a id="opesw">Open .p3d</a>
				<label id="oesw"></label>
			</div>
		</div>
		<script>
			var P3D = (function() {
				const unzip = function(arrayBuffer, uncompressedSizesize, startOffset) {
					const fixedDistTable = {
						key: [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
						value: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]
					}, fixedLitTable = {
						key: [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9],
						value: [256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 280, 281, 282, 283, 284, 285, 286, 287, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]
					}, ORDER = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), LEXT = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99]), LENS = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), DEXT = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), DISTS = new Uint16Array([ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]), stream = new Uint8Array(arrayBuffer), _data = new Uint8Array(uncompressedSizesize);
					var _size = (startOffset || 0), byte_offset = _size + 2, bit_offset = 8, bit_buffer = null;
					const readNumber = function(n) {
						let a = 0, o = byte_offset, i = o + n;
						while (i > o) a = (a << 8) | stream[--i];
						byte_offset += n;
						return a;
					}
					const readUB = function(length) {
						let value = 0;
						for (let i = 0; i < length; i++) {
							if (bit_offset === 8) {
								bit_buffer = readNumber(1);
								bit_offset = 0;
							}
							value |= (bit_buffer & (1 << bit_offset++) ? 1 : 0) << i;
						}
						return value;
					}
					const buildHuffTable = function(data) {
						const length = data.length;
						const blCount = [];
						const nextCode = [];
						let maxBits = 0;
						let i = length;
						let len = 0;
						while (i--) {
							len = data[i];
							maxBits = Math.max(maxBits, len);
							blCount[len] = (blCount[len] || 0) + (len > 0);
						}
						let code = 0;
						for (i = 0; i < maxBits; i++) {
							len = i;
							if (!(len in blCount)) blCount[len] = 0;
							code = (code + blCount[len]) << 1;
							nextCode[i + 1] = code | 0;
						}
						const key = [];
						const value = [];
						for (i = 0; i < length; i++) {
							len = data[i];
							if (len) {
								const tt = nextCode[len];
								key[tt] = len;
								value[tt] = i;
								nextCode[len] = tt + 1 | 0;
							}
						}
						return { key, value };
					}
					const decodeSymbol = function(key, value) {
						let len = 0;
						let code = 0;
						while (true) {
							code = (code << 1) | readUB(1);
							len++;
							if (!(code in key)) continue;
							if (key[code] === len) return value[code];
						}
					}
					var sym = 0, i = 0, length = 0, flag = 0;
					const codeLengths = new Uint8Array(19);
					while (!flag) {
						flag = readUB(1);
						let type = readUB(2);
						let distTable = null;
						let litTable = null;
						switch (type) {
							case 0:
								bit_offset = 8;
								bit_buffer = null;
								length = readNumber(2);
								readNumber(2);
								while (length--) _data[_size++] = readNumber(1);
								break;
							default:
								switch (type) {
									case 1:
										distTable = fixedDistTable;
										litTable = fixedLitTable;
										break;
									default:
										const numLitLengths = readUB(5) + 257;
										const numDistLengths = readUB(5) + 1;
										const numCodeLengths = readUB(4) + 4;
										for (i = 0; i < numCodeLengths; i++) codeLengths[ORDER[i]] = readUB(3);
										const codeTable = buildHuffTable(codeLengths);
										codeLengths.fill(0);
										var prevCodeLen = 0;
										const maxLengths = numLitLengths + numDistLengths;
										const litLengths = new Uint8Array(maxLengths);
										let litLengthSize = 0;
										while (litLengthSize < maxLengths) {
											sym = decodeSymbol(codeTable.key, codeTable.value);
											switch (sym) {
												case 0:
												case 1:
												case 2:
												case 3:
												case 4:
												case 5:
												case 6:
												case 7:
												case 8:
												case 9:
												case 10:
												case 11:
												case 12:
												case 13:
												case 14:
												case 15:
													litLengths[litLengthSize++] = sym;
													prevCodeLen = sym;
													break;
												case 16:
													i = readUB(2) + 3;
													litLengths.fill(prevCodeLen, litLengthSize, litLengthSize + i);
													litLengthSize += i;
													break;
												case 17:
													i = readUB(3) + 3;
													litLengthSize += i;
													break;
												case 18:
													i = readUB(7) + 11;
													litLengthSize += i;
													break;
											}
										}
										distTable = buildHuffTable(litLengths.subarray(numLitLengths));
										litTable = buildHuffTable(litLengths.subarray(0, numLitLengths));
								}
								sym = 0;
								while (true) {
									sym = (0 | decodeSymbol(litTable.key, litTable.value));
									if (256 === sym) break;
									if (sym < 256) {
										_data[_size++] = sym;
									} else {
										const mapIdx = sym - 257 | 0;
										length = LENS[mapIdx] + readUB(LEXT[mapIdx]) | 0;
										const distMap = decodeSymbol(distTable.key, distTable.value);
										i = _size - (DISTS[distMap] + readUB(DEXT[distMap]) | 0) | 0;
										while (length--) _data[_size++] = _data[i++];
									}
								}
						}
					}
					return _data.buffer;
				}
				const Byte = function(arrayBuffer) {
			        this.arrayBuffer = arrayBuffer;
			        this.position = 0;
			        this.viewData = new DataView(this.arrayBuffer, 0);
			    }
				Byte.prototype.byteAva = function() {
					return this.arrayBuffer.byteLength - this.position;
				}
				Byte.prototype.readString = function() {
					var result = "";
					while (true) {
						var b = this.readUint8();
						if (b == 0) break;
						result += String.fromCharCode();
					}
					return result;
				}
				Byte.prototype.readBytes = function(length) {
					var res = this.arrayBuffer.slice(this.position, this.position + length);
					return this.position += length,res
				}
				Byte.prototype.readUint8 = function() {
					return this.viewData.getUint8(this.position++);
				}
				Byte.prototype.readUint16 = function() {
					var val = this.viewData.getUint16(this.position, true);
					return this.position += 2,val
				}
				Byte.prototype.readUint24 = function() {
					var val1 = this.viewData.getUint8(this.position++);
					var val2 = this.viewData.getUint8(this.position++);
					var val3 = this.viewData.getUint8(this.position++);
					return val1 + (val2 * 256) + (val3 * 65536);
				}
				Byte.prototype.readUint32 = function() {
					var val = this.viewData.getUint32(this.position, true);
					return this.position += 4,val
				}
				Byte.prototype.readInt16 = function() {
					var val = this.viewData.getInt16(this.position, true);
					return this.position += 2,val
				}

				// 1 HUN 8BIT 6 * 6 * 6
				const hunToRGB = function(h) {
			        var r = Math.round(((Math.floor(h / 36) % 6) / 5) * 255);
			        var g = Math.round(((Math.floor(h / 6) % 6) / 5) * 255);
			        var b = Math.round(((h % 6) / 5) * 255);
			        return [b, g, r];
			    }
				const HUNDecoder = function(renderer) {
					this.renderer = renderer;
				}
				HUNDecoder.prototype.decode = function(buffer) {
					var b = new Byte(buffer);
					var blockX = 0;
					var blockY = 0;
					var blockLen = b.readUint8();
					if (blockLen == 0) {
						blockLen = 16;
						var isB6 = false;
						var kof = b.readUint8();
						if (kof == 255) {
							isB6 = true;
						} else {
							b.position = 1;
						}
						while(true) {
							var isFlag = b.readUint8();
							if (isFlag == 0) break;
							if (isFlag == 3) {
								blockX = b.readUint8() * blockLen;
								blockY = b.readUint8() * blockLen;	
							} else {
								if (!isB6) {
									blockX = b.readUint8() * blockLen;
									blockY = b.readUint8() * blockLen;	
								}
								var c = b.readUint8();
								if (isFlag == 2) {
									for (var h = 0; h < blockLen; h++)
						        		for (var t = 0; t < blockLen; t++) {
						        			var hx = blockX + h;
						        			var hy = blockY + t;
					        				var result = hunToRGB(c);
					        				this.renderer.setColor(hx, hy, result[0], result[1], result[2]);
						        		}
								} else {
									var bLen = b.readUint16();
							    	while (bLen--) {
							    		var u = b.readUint8();
							    		var h = u & 0xf;
							    		var t = u >> 4;
					        			var hx = blockX + h;
					        			var hy = blockY + t;
					        			var result = hunToRGB(c);
					        			this.renderer.setColor(hx, hy, result[0], result[1], result[2]);
					        		}	
								}	
							}
						}
					} else {
						while(true) {
							var isFlag = b.readUint8();
							if (isFlag == 0) break;
							blockX = b.readUint8() * blockLen;
							blockY = b.readUint8() * blockLen;
							var data = new Uint16Array(blockLen*blockLen);
							for (var i = 0; i < data.length; i++)
								data[i] = b.readUint8();
					    	for (var h = 0; h < blockLen; h++)
				        		for (var t = 0; t < blockLen; t++) {
				        			var hx = blockX + h;
				        			var hy = blockY + t;
				        			var result = hunToRGB(data[h + (t * blockLen)])
				        			this.renderer.setColor(hx, hy, result[0], result[1], result[2]);
				        		}
						}
					}
				}
				// 2 BEX 24BIT 16 * 16 * 16 RGBRGB Uint24Bit
				const bexToRGB = function(h) {
			        var r = Math.round(((Math.floor(h / 256) % 16) / 15) * 255);
			        var g = Math.round(((Math.floor(h / 16) % 16) / 15) * 255);
			        var b = Math.round((((h & 15) / 15) * 255));
			        return [b, g, r];
			    }
				const BEXDecoder = function(renderer) {
					this.renderer = renderer;
				}
				BEXDecoder.prototype.decode = function(buffer) {
					var b = new Byte(buffer);
					var blockLen = 16;
					var isB6 = false;
					var kof = b.readUint8();
					if (kof == 255) {
						blockLen = 6;
						isB6 = true;
					} else {
						if (kof == 254) {
							isB6 = true;
						} else {
							b.position = 0;
						}
					}
					var blockX = 0;
					var blockY = 0;
					while(true) {
						var isFlag = b.readUint8();
						if (isFlag == 0) break;
						if (isFlag == 3) {
							blockX = b.readUint8() * blockLen;
							blockY = b.readUint8() * blockLen;	
						} else {
							var has1 = false;
							if ((isFlag !== 2) && (b.readUint8())) has1 = true;
							if (!isB6) {
								blockX = b.readUint8() * blockLen;
								blockY = b.readUint8() * blockLen;	
							}
							if (isFlag == 2) {
								var c = b.readUint16();
								for (var h = 0; h < blockLen; h++)
					        		for (var t = 0; t < blockLen; t++) {
					        			var hx = blockX + h;
					        			var hy = blockY + t;
					        			var hi = bexToRGB(c);
					        			this.renderer.setColor(hx, hy, hi[0], hi[1], hi[2]);
					        		}
							} else {
								var c;
								if (has1) {
									c = b.readUint24();
								} else {
									c = b.readUint16();
								}
								var c1 = c % 4096;
								var c2 = Math.floor(c / 4096);
								var bLen = b.readUint16();
						    	while (bLen--) {
						    		var u = b.readUint8();
						    		var h = u & 0xf;
						    		var t = u >> 4;
				        			var hx = blockX + h;
				        			var hy = blockY + t;
				        			var hi = bexToRGB(c1);
				        			this.renderer.setColor(hx, hy, hi[0], hi[1], hi[2]);
				        		}
				        		if (has1) {
					        		var bLen2 = b.readUint16();
							    	while (bLen2--) {
							    		var u = b.readUint8();
							    		var h = u & 0xf;
							    		var t = u >> 4;
					        			var hx = blockX + h;
					        			var hy = blockY + t;
					        			var hi = bexToRGB(c2);
					        			this.renderer.setColor(hx, hy, hi[0], hi[1], hi[2]);
					        		}	
				        		}	
							}	
						}
					}
				}

				const R8Decoder = function(buffer, samplePerBlock) {
					this.buffer = buffer;
					this.lf = buffer.getChannelData(0);
					this.rf = (buffer.numberOfChannels == 2) ? buffer.getChannelData(1) : null;
					this.samplePerBlock = samplePerBlock;
					this.sid = 0;
				}
				R8Decoder.prototype.decode = function(data) {
					var b = new Byte(data);
					try {
						while(b.byteAva() > 0) {
							this.lf[this.sid] = ((b.readUint8() - 128) / 128);
							if (this.buffer.numberOfChannels == 2) {
								this.rf[this.sid] = ((b.readUint8() - 128) / 128);
							}
							this.sid++;
						}
					} catch(e) {
					}
				}
				const R16Decoder = function(buffer, samplePerBlock) {
					this.buffer = buffer;
					this.lf = buffer.getChannelData(0);
					this.rf = (buffer.numberOfChannels == 2) ? buffer.getChannelData(1) : null;
					this.samplePerBlock = samplePerBlock;
					this.sid = 0;
				}
				R16Decoder.prototype.decode = function(data) {
					var b = new Byte(data);
					try {
						while(b.byteAva() > 0) {
							this.lf[this.sid] = (b.readInt16() / 0x7fff);
							if (this.buffer.numberOfChannels == 2) this.rf[this.sid] = (b.readInt16() / 0x7fff);
							this.sid++;
						}
					} catch(e) {
					}
				}
				const P3DParser = function(buffer) {
					this.byte = new Byte(buffer);
				}
				P3DParser.prototype.byteAva = function() {
					return this.byte.byteAva();
				}
				P3DParser.prototype.readHeader = function() {
					this.byte.readUint8();
					this.byte.readUint8();
					this.byte.readUint8();
					var unc = this.byte.readUint8();
					var ver = this.byte.readUint8();
					var uncLen = 0;
					if (ver >= 2) {
						if (this.byte.readUint8()) this.byte.readString();
						if (this.byte.readUint8()) this.byte.readString();
						if (unc > 0) uncLen = this.byte.readUint32();
					}
					return {
						compression: unc,
						uncLen: uncLen,
						verion: ver
					}
				}
				P3DParser.prototype.decompress = function(header) {
					var c = header.compression;
					if (c == 1) {
						var st = this.byte.position;
						this.byte = new Byte(unzip(this.byte.arrayBuffer, header.uncLen, st));
						this.byte.position = st;
					}
				}
				P3DParser.prototype.readFormat = function() {
					var width = this.byte.readUint16();
					var height = this.byte.readUint16();
					var frameRate = this.byte.readUint8();
					var numFrames = this.byte.readUint16();
					var typeVideo = this.byte.readUint8();
					var typeAudio = this.byte.readUint8();
					return {
						width,
						height,
						frameRate,
						numFrames,
						typeVideo,
						typeAudio,
					}
				}
				P3DParser.prototype.readAudioFormat = function() {
					var typRate = this.byte.readUint8();
					var rate;
					switch(typRate) {
						case 0:
							rate = 11025;
							break;
						case 1:
							rate = 22050;
							break;
						case 2:
							rate = 44100;
							break;
					}
					var channels = (this.byte.readUint8() ? 2 : 1);
					var samplePerBlock = this.byte.readUint16();
					return {
						rate,
						channels,
						samplePerBlock
					}
				}
				P3DParser.prototype.readVideoData = function() {
					var len = this.byte.readUint32();
					return this.byte.readBytes(len);
				}
				P3DParser.prototype.readFrame = function(stateVideo, stateAudio) {
					var hun;
					if (stateVideo) hun = this.readVideoData();
					var au = null;
					if (stateAudio) au = this.readVideoData();
					return {
						videoData: hun,
						audioData: au,
					}
				}
				const RenderCanvas2d = function(w, h) {
					this.canvas = document.createElement('canvas');
					this.canvas.width = w;
					this.canvas.height = h;
					this.width = w;
					this.height = h;
			        this.ctx = this.canvas.getContext("2d");
					this.dirty = false;
					this.imageData = this.ctx.createImageData(w, h);
					this.data = this.imageData.data;
				}
				RenderCanvas2d.prototype.setWH = function(w, h) {
					this.canvas.width = w;
					this.canvas.height = h;
					this.width = w;
					this.height = h;
				}
				RenderCanvas2d.prototype.setColor = function(x, y, r, g, b) {
					var i = (x + (y * this.width)) * 4;
					this.data[i] = b;
					this.data[i + 1] = g;
					this.data[i + 2] = r;
					this.data[i + 3] = 255;
					this.dirty = true;
				}
				RenderCanvas2d.prototype.flush = function() {
					if (this.dirty) {
						this.ctx.putImageData(this.imageData, 0, 0);
						this.dirty = false;	
					}
				}
				const MovieP3D = function() {
					this.audioContext = new AudioContext();
					this.node = this.audioContext.createGain();
					this.node.connect(this.audioContext.destination);
					this.canvas = null;
					this.width = 100;
					this.height = 100;
					this.frameRate = 12;
					this.numFrames = 0;
					this.frameId = 0;
					this.audioBuffer = null;
					this.sourceBuffer = null;
					this.dirty = false;
					this.frames = [];
					this.typeVideo = 0;
					this.typeAudio = 0;
					this.frameAccumulator = 0;
					this.videoDecoder = null;
					this.audioDecoder = null;
					this.isPlaying = this.audioContext.state == "running";
				}
				MovieP3D.prototype.destroy = function() {
					if (this.sourceBuffer) {
						this.sourceBuffer.disconnect();
						this.sourceBuffer = null;
					}
				}
				MovieP3D.prototype.getVolume = function() {
					return this.node.gain.value * 100;
				}
				MovieP3D.prototype.setVolume = function(volume) {
					this.node.gain.value = volume / 100;
				}
				MovieP3D.prototype.play = function() {
					this.isPlaying = true;
					if (this.isPlaying) this.playAudio(this.frameId / this.frameRate);
				}
				MovieP3D.prototype.pause = function() {
					this.isPlaying = false;
					if (this.sourceBuffer) {
						this.sourceBuffer.disconnect();
						this.sourceBuffer = null;
					}
				}
				MovieP3D.prototype.setWH = function(w, h) {
					this.width = w;
					this.height = h;
				}
				MovieP3D.prototype.resize = function(w, h) {
					this.canvas.width = w;
					this.canvas.height = h;
					this.dirty = true;
				}
				MovieP3D.prototype.getDuration = function() {
					return this.numFrames / this.frameRate
				}
				MovieP3D.prototype.runFrame = function() {
					if (this.frameId >= this.frames.length) {
						this.frameId = 0;
						if (this.isPlaying) this.playAudio();
					}
					if (this.videoDecoder) this.videoDecoder.decode(this.frames[this.frameId].videoData);
					this.frameId++;
					this.dirty = true;
				}
				MovieP3D.prototype.gotoFrame = function(frame) {
					var isR = frame < this.frameId;
					if (isR) {
						this.frameId = 0;
					}
					while (this.frameId < frame) {
						if (this.videoDecoder) this.videoDecoder.decode(this.frames[this.frameId].videoData);
						this.frameId++;
					}
					this.dirty = true;
					if (this.isPlaying) this.playAudio(this.frameId / this.frameRate);
				}
				MovieP3D.prototype.loadP3d = function(buffer) {
					var parser = new P3DParser(buffer);
					var he = parser.readHeader();
					parser.decompress(he);
					var rs = parser.readFormat();
					var renderer = new RenderCanvas2d(rs.width, rs.height);
					this.canvas = renderer.canvas;
					this.renderer = renderer;
					this.setWH(rs.width, rs.height);
					this.frameRate = rs.frameRate;
					this.numFrames = rs.numFrames;
					this.typeVideo = rs.typeVideo;
					this.typeAudio = rs.typeAudio;
					var ga;
					if (this.typeAudio) {
						ga = parser.readAudioFormat();
						this.audioBuffer = this.audioContext.createBuffer(ga.channels, ga.samplePerBlock * this.numFrames, ga.rate);
					}
					var frames = this.frames;
					try {
						while(parser.byteAva() > 0) {
							var g = parser.readFrame(this.typeVideo, this.typeAudio);
							frames.push(g);
						}
					} catch(e) {
					}
					switch(rs.typeVideo) {
						case 1:
							this.videoDecoder = new HUNDecoder(renderer);
							break;
						case 2:
							this.videoDecoder = new BEXDecoder(renderer);
							break;
					}
					if (this.typeAudio) {
						switch(rs.typeAudio) {
							case 1:
								this.audioDecoder = new R8Decoder(this.audioBuffer, ga.samplePerBlock);
								break;
							case 2:
								this.audioDecoder = new R16Decoder(this.audioBuffer, ga.samplePerBlock);
								break;
						}
						for (var i = 0; i < frames.length; i++) {
							this.audioDecoder.decode(frames[i].audioData);
						}
					}
					if (this.isPlaying) this.playAudio();
				}
				MovieP3D.prototype.tick = function(deltaTime) {
					if (this.isPlaying) {
						this.frameAccumulator += deltaTime;
						var frameTime = +(1000 / this.frameRate).toFixed(1);
						if (this.frameAccumulator >= frameTime) {
							this.frameAccumulator -= frameTime;
							this.runFrame();
						}	
					}
				}
				MovieP3D.prototype.render = function() {
					if (this.dirty) {
			        	this.renderer.flush();
						this.dirty = false;
					}
				}
				MovieP3D.prototype.playAudio = function(start) {
					if (this.audioBuffer) {
						if (this.sourceBuffer) {
							this.sourceBuffer.disconnect();
							this.sourceBuffer = null;
						}
						this.sourceBuffer = this.audioContext.createBufferSource();
						this.sourceBuffer.buffer = this.audioBuffer;
						this.sourceBuffer.connect(this.node);
						this.sourceBuffer.start(this.audioContext.currentTime, start || 0);	
					}
				}
				function getDuraction(num) {
					var txt = '';
					var _ms = Math.floor(num);
					var _mm = Math.floor(num / 60);
					var ms = _ms % 60;
					var mm = _mm % 60;
					var mh = Math.floor(num / 3600);
					if (_mm >= 60) {
						txt += '' + mh;
						txt += ':';
					}
					if ((mm >= 10) || (_ms < 600))
						txt += '' + mm;
					else
						txt += '0' + mm;
					txt += ':';
					if (ms >= 10)
						txt += '' + ms;
					else 
						txt += '0' + ms;
					return txt;
				}
				const Slot = function() {
					this._listeners = [];
				}
				Slot.prototype.subscribe = function(fn) {
					this._listeners.push(fn);
				}
				Slot.prototype.emit = function() {
					for (const listener of this._listeners) listener(...arguments);
				}
				const Player = function() {
					this.onload = new Slot();
					this.onstartload = new Slot();
					this.oncleanup = new Slot();
					this.onerror = new Slot();
					this.onprogress = new Slot();
					this.volume = 100;
					this.root = document.createElement('div');
					this.mouseX = 0;
					this.mouseY = 0;
					var _this = this;
					_this.startDate = Date.now();
					this.playerContainer = document.createElement('div');
					this.playerContainer.onmousemove = function(e) {
						_this.startDate = Date.now();
					}
					this.playerContainer.className = 'pinkfie-player-stage';
					this.playerContainer.style.position = 'relative';
					this.root.appendChild(this.playerContainer);
					this.playerControls = document.createElement('div');
					this.playerControls.style.overflow = 'hidden';
					this.playerControls.style.position = 'absolute';
					this.playerControls.style.bottom = '0';
					this.playerControls.style.left = '50%';
					this.playerControls.style.padding = '6px';
					this.playerControls.style.transform = 'translate(-50%, 0)';
					this.playerControls.style.background = 'rgba(0, 0, 0, 0.6)';
					this.playerControls.style.width = '100%';
					this.playerControls.style.height = '20px';
					this.playerControls.style.display = 'none';
					this.playerPlayPause = document.createElement('a');
					this.playerPlayPause.style.color = '#fff';
					this.playerPlayPause.innerHTML = "Play";
					this.playerPlayPause.onclick = this.playPause.bind(this);
			        this.playerControls.appendChild(this.playerPlayPause);
					this.playerLabel = document.createElement('label');
					this.playerLabel.style.color = '#fff';
					this.playerLabel.innerHTML = "0:00/0:00";
			        this.playerControls.appendChild(this.playerLabel);
					this.playerRange = document.createElement('input');
					this.playerRange.style.width = '320px';
					this.playerRange.type = 'range';
					this.playerRange.min = 1;
					this.playerRange.max = 26;
					this.playerRange.value = 1;
					this.playerRange.addEventListener("input", function() {
						this.gotoFrame(+this.playerRange.value);
					}.bind(this));
			        this.playerControls.appendChild(this.playerRange);
					this.playerVolumeLabel = document.createElement('label');
					this.playerVolumeLabel.style.color = '#fff';
					this.playerVolumeLabel.style.float = 'right';
					this.playerVolumeLabel.innerHTML = "volume:";
					this.playerVolumeRange = document.createElement('input');
					this.playerVolumeRange.style.width = '50px';
					this.playerVolumeRange.style.float = 'right';
					this.playerVolumeRange.type = 'range';
					this.playerVolumeRange.min = 0;
					this.playerVolumeRange.max = 100;
					this.playerVolumeRange.value = 100;
					this.playerVolumeRange.addEventListener("input", function() {
						this.setVolume(+this.playerVolumeRange.value);
					}.bind(this));
			        this.playerControls.appendChild(this.playerVolumeRange);
			        this.playerControls.appendChild(this.playerVolumeLabel);
			        this.playerContainer.appendChild(this.playerControls);
			        this.movie = null;
			        this.width = 360;
			        this.height = 360;
					this.startTime = Date.now();
					this.startOffest = 0;
					this.hasControls = true;
					this.resize(640, 360);
			        setInterval(this.step.bind(this), 10);
				}
				Player.prototype.getTime = function() {
					return this.movie ? (this.movie.frameId / this.movie.frameRate) : 0;
				}
				Player.prototype.getNumFrame = function() {
					return this.movie ? (this.movie.numFrames / this.movie.frameRate) : 0;
				}
				Player.prototype.gotoFrame = function(frame) {
					if (this.movie) {
						this.movie.gotoFrame(frame);
					}
				}
				Player.prototype.playPause = function() {
					if (this.movie) {
						if (this.movie.isPlaying) {
							this.movie.pause();
							this.playerPlayPause.innerHTML = "Play";
						} else {
							this.movie.play();
							this.playerPlayPause.innerHTML = "Pause";
						}
					}
				}
				Player.prototype.resize = function(w, h) {
			        this.width = w;
			        this.height = h;
			        this.playerContainer.style.width = w + "px";
			        this.playerContainer.style.height = h + "px";
					this.playerRange.style.width = (w - 230) + 'px';
			        this.render();
			        this.applyResizeMovie();
				}
				Player.prototype.getRectStage = function() {
					var _movieCanvas = this.movie.canvas;
					var w = 0, h = 0, x = 0, y = 0;
					var __Width = this.width;
					var __Height = this.height;
					if ((__Height - (_movieCanvas.height * (__Width / _movieCanvas.width))) < 0) {
						w = (_movieCanvas.width * (__Height / _movieCanvas.height));
						h = (_movieCanvas.height * (__Height / _movieCanvas.height));
						x = (__Width - w) / 2;
					} else {
						w = (_movieCanvas.width * (__Width / _movieCanvas.width));
						h = (_movieCanvas.height * (__Width / _movieCanvas.width));
						y = (__Height - h) / 2;
					}
					return [x, y, w, h];
				}
				Player.prototype.applyResizeMovie = function() {
					if (this.movie) {
						var rect = this.getRectStage();
						var canvas = this.movie.canvas;
						canvas.style.margin = '0';
						canvas.style.position = 'absolute';
						canvas.style.left = rect[0] + 'px';
						canvas.style.top = rect[1] + 'px';
						canvas.style.width = rect[2] + 'px';
						canvas.style.height = rect[3] + 'px';
						canvas.style.imageRendering = 'pixelated';
						if (this.clickToPlayContainer) {
							this.clickToPlayContainer.style.top = rect[1] + "px";
							this.clickToPlayContainer.style.left = rect[0] + "px";
							this.clickToPlayContainer.style.width = rect[2] + "px";
							this.clickToPlayContainer.style.height = rect[3] + "px";
						}
			        	this.movie.render();
					}
				}
				Player.prototype.step = function() {
					if (((Date.now() - this.startDate) > 1250) || this.clickToPlayContainer || !this.movie || !this.hasControls) {
						this.playerControls.style.display = 'none';
						if (this.movie && this.hasControls && !this.clickToPlayContainer) this.playerContainer.style.cursor = "none";
						else this.playerContainer.style.cursor = "";
					} else {
						this.playerControls.style.display = '';
						if (this.hasControls) this.playerContainer.style.cursor = "";
					}
			        if (this.movie) {
			        	if (!this.movie.isPlaying || ("ontouchstart" in window)) {
							this.startDate = Date.now();
			        	}
						this.playerRange.min = 1;
						this.playerRange.max = this.movie ? this.movie.numFrames : 0;
						this.playerRange.value = this.movie ? this.movie.frameId : 0;
			        	this.playerLabel.innerHTML = getDuraction(this.getTime()) + "/" + getDuraction(this.getNumFrame());
						while ((Date.now() - this.startTime) >= this.startOffest) {
			    			this.movie.tick(10);
							this.startOffest += 10;
						}
			        } else {
						this.playerRange.min = 1;
						this.playerRange.max = 1;
						this.playerRange.value = 1;
			        }
			        this.render();
				}
				Player.prototype.render = function() {
			        if (this.movie) {
			        	this.movie.render();
			        }
				}
				Player.prototype.setVolume = function(volume) {
					this.volume = volume;
					this.playerVolumeRange.value = this.volume;
					if (this.movie) {
						this.movie.setVolume(this.volume);
					}
				}
				Player.prototype.beginLoadingP3D = function() {
					this.cleanup();
					this.onstartload.emit();
				}
				Player.prototype.cleanup = function() {
					if (this.movie) {
						this.playerContainer.removeChild(this.movie.canvas);
						this.movie.destroy();
						this.movie = null;
					}
					this.removeClickToPlayContainer();
				}
				Player.prototype.setMovie = function(movie) {
				    this.movie = movie;
					this.startOffest = 0;
					this.startTime = Date.now();
					this.setVolume(this.volume);
					if (this.movie.isPlaying) this.playerPlayPause.innerHTML = "Pause";
					else this.playerPlayPause.innerHTML = "Play";
					this.playerContainer.insertBefore(movie.canvas, this.playerContainer.childNodes[0]);
					this.movie.resize(this.movie.width, this.movie.height);
					if (!this.movie.isPlaying) this.showClickToPlayContainer();
					this.applyResizeMovie();
					this.onload.emit(movie);
				}
				Player.prototype.loadP3dFromBuffer = function(buffer) {
					this.beginLoadingP3D();
					var movie = new MovieP3D();
					movie.loadP3d(buffer);
					this.setMovie(movie);
				}
				Player.prototype.triggerStartMovie = function() {
					this.playPause();
					this.removeClickToPlayContainer();
				}
				Player.prototype.showClickToPlayContainer = function() {
					if (!this.clickToPlayContainer) {
						this.clickToPlayContainer = document.createElement('div');
						this.clickToPlayContainer.style.position = "absolute";
						this.clickToPlayContainer.style.top = "0";
						this.clickToPlayContainer.style.left = "0";
						this.clickToPlayContainer.style.width = "100%";
						this.clickToPlayContainer.style.height = "100%";
						this.clickToPlayContainer.style.cursor = "pointer";
						this.clickToPlayContainer.style.background = "rgba(0, 0, 0, 0.6)";
						this.clickToPlayContainer.style.display = "flex";
						this.clickToPlayContainer.style["align-items"] = "center";
						this.clickToPlayContainer.style["justify-content"] = "center";
						this.clickToPlayContainer.onclick = () => {
							this.triggerStartMovie();
						};
						const content = document.createElement('div');
						content.style.width = "10em";
						content.style.height = "10em";
						content.style["background-image"] = "url(data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMTkuNzkzNzIiIGhlaWdodD0iMTE5Ljc5MzcyIiB2aWV3Qm94PSIwLDAsMTE5Ljc5MzcyLDExOS43OTM3MiI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTE4MC4xMDMxNCwtMTIwLjEwMzE0KSI+PGcgZGF0YS1wYXBlci1kYXRhPSJ7JnF1b3Q7aXNQYWludGluZ0xheWVyJnF1b3Q7OnRydWV9IiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9Im5vbnplcm8iIHN0cm9rZT0iI2ZmZmZmZiIgc3Ryb2tlLXdpZHRoPSI2IiBzdHJva2UtbGluZWNhcD0iYnV0dCIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBzdHJva2UtZGFzaGFycmF5PSIiIHN0cm9rZS1kYXNob2Zmc2V0PSIwIiBzdHlsZT0ibWl4LWJsZW5kLW1vZGU6IG5vcm1hbCI+PHBhdGggZD0iTTE4My4xMDMxNCwxODBjMCwtMzEuNDIzMjcgMjUuNDczNTksLTU2Ljg5Njg2IDU2Ljg5Njg2LC01Ni44OTY4NmMzMS40MjMyNywwIDU2Ljg5Njg2LDI1LjQ3MzU5IDU2Ljg5Njg2LDU2Ljg5Njg2YzAsMzEuNDIzMjcgLTI1LjQ3MzU5LDU2Ljg5Njg2IC01Ni44OTY4Niw1Ni44OTY4NmMtMzEuNDIzMjcsMCAtNTYuODk2ODYsLTI1LjQ3MzU5IC01Ni44OTY4NiwtNTYuODk2ODZ6Ii8+PHBhdGggZD0iTTIyNS43MTY3NywyMDMuNjA4NjZ2LTQ2Ljc0NTEzbDMzLjc2MDM3LDIzLjM3MjU3eiIvPjwvZz48L2c+PC9zdmc+)";
						content.style["background-size"] = "100% 100%";
						this.clickToPlayContainer.appendChild(content);
						this.playerContainer.insertBefore(this.clickToPlayContainer, this.playerContainer.childNodes[1]);
					}
				}
				Player.prototype.removeClickToPlayContainer = function() {
					if (this.clickToPlayContainer) {
						this.playerContainer.removeChild(this.clickToPlayContainer);
						this.clickToPlayContainer = null;
					}
				}
				return {
					Player
				}
			}());
		</script>
		<script>
			var pinkswf = document.getElementById('pinkswf');

			pinkswf.style.display = "none";

            var player = new P3D.Player();
            pinkswf.appendChild(player.root);

			function _resize_() {
				player.resize(window.innerWidth, window.innerHeight);
			}
			window.addEventListener("resize", _resize_);
			_resize_();

			var opesw = document.getElementById('opesw');
			var ecdx = document.getElementById('ecdx');

			var sasw = document.getElementById('sasw');

			var oesw = document.getElementById('oesw');

			setInterval(function() {
				if ((player.playerControls.style.display == "none") && player.movie && !player.clickToPlayContainer) {
					opesw.style.display = "none";
					sasw.style.display = "none";
				} else {
					opesw.style.display = "";
					sasw.style.display = "";
				}
			}, 50)

			function loadMd5(url) {
				pinkswf.style.display = "none";
				oesw.textContent = "";
				player.cleanup();
				if (!url) return;
				fetch("https://assets.scratch.mit.edu/internalapi/asset/" + url + "/get/").then((e) => {
					e.arrayBuffer().then((e1) => {
						var dat = new Uint8Array(e1.slice(0x2c));
						player.loadP3dFromBuffer(dat.buffer);
						pinkswf.style.display = "";
					});
				});
			}

			function dropHandler(ev) {
				ev.preventDefault();
				if (ev.dataTransfer.items) {
					[...ev.dataTransfer.items].forEach((item, i) => {
						if (item.kind === 'file') {
							opesw.style.display = "";
							sasw.style.display = "";
							const file = item.getAsFile();
							var r = new FileReader();
							r.onload = function(e) {
								player.loadP3dFromBuffer(e.target.result);
								pinkswf.style.display = "";
							}
							r.readAsArrayBuffer(file);
						}
					});
				}
			}
			function dragOverHandler(ev) {
				ev.preventDefault();
			}

			var drop_zone = document.querySelector(".app");
			drop_zone.ondrop = dropHandler;
			drop_zone.ondragover = dragOverHandler;

			ecdx.addEventListener("change", function() {
				loadMd5(ecdx.value);
				ecdx.value = '';
			});
			ecdx.value = '';

			opesw.onclick = function() {
				var sa = document.createElement('input');
				sa.type = 'file';
				sa.accept = '.p3d';
				sa.addEventListener('change', function(e) {
					var file = e.target.files[0];
					if (!file) return;
					opesw.style.display = "";
					sasw.style.display = "";
					oesw.textContent = file.name;
					var r = new FileReader();
					r.onload = function(e) {
						player.loadP3dFromBuffer(e.target.result);
						pinkswf.style.display = "";
					}
					r.readAsArrayBuffer(file);
				}, false);
				sa.click();
			}
		</script>
	</body>
</html>